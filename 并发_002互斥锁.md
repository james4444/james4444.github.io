# 并发编程

## 互斥锁

原子性问题的根源是线程切换。单cpu时代，可以用禁用cpu切换，保证cpu执行该操作时不被中断解决。多核时代，需要保证同一时刻，只有一个线程执行，也就是互斥。通过保证共享变量的修改时互斥的，来保证操作的原子性

互斥的解决方案时加锁，锁是一种通用的解决方案，java语言提供了sychronized关键字，就是锁的一种实现。

当sychronized修饰静态方法的时候，锁定的是当前类（class）.当修饰的是非静态方法的时候，锁定的是当前对象（this）.

锁需要特别注意的是锁定的资源,只有锁定的是同一资源的时候，才具有互斥性。根据happens-before规则，对一个锁的解锁happens-before于后续对这个锁的枷锁，可以保证共享变量是可见的

如何通过锁保护多个资源：

* 如果资源之间没有关系，每个资源用一把锁就可以了

* 如果资源之间存在关联关系，就要选择一个更大粒度的锁，比如锁定class对象。有必要，可以创建一个锁。

注意：不能用可变对象做锁


总结：原子性的本质是操作的中间状态对外不可见，解决原子性问题，就是要保证中间状态对外不可见

